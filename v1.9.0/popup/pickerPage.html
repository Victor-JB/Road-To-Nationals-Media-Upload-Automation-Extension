<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Select Videos from Google Drive</title>
		<style>
			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
					sans-serif;
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				margin: 0;
				background: #f5f5f5;
			}
			.loading {
				text-align: center;
				color: #666;
			}
			.loading-spinner {
				width: 40px;
				height: 40px;
				border: 4px solid #e0e0e0;
				border-top-color: #4285f4;
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin: 0 auto 16px;
			}
			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
			.error {
				color: #d93025;
				text-align: center;
				padding: 20px;
			}
		</style>
	</head>
	<body>
		<div class="loading" id="loading">
			<div class="loading-spinner"></div>
			<p>Loading Google Drive Picker...</p>
		</div>
		<div class="error" id="error" style="display: none"></div>

		<!-- Google API Script - loads here because extension pages block it via CSP -->
		<script src="https://apis.google.com/js/api.js"></script>
		<script>
			// Parse URL parameters
			const params = new URLSearchParams(window.location.search);
			const accessToken = params.get("token");
			const apiKey = params.get("apiKey");
			const appId = params.get("appId");

			function showError(message) {
				document.getElementById("loading").style.display = "none";
				const errorDiv = document.getElementById("error");
				errorDiv.style.display = "block";
				errorDiv.textContent = message;
			}

			function sendResult(result) {
				// Send result back to extension via chrome.runtime.sendMessage
				if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
					chrome.runtime.sendMessage(result, () => {
						window.close();
					});
				} else {
					// Fallback: try window.opener
					if (window.opener) {
						window.opener.postMessage(result, "*");
					}
					window.close();
				}
			}

			// Validate required parameters
			if (!accessToken || !apiKey || !appId) {
				showError("Missing required parameters. Please try again.");
			} else {
				// Load the Picker API
				gapi.load("picker", {
					callback: initPicker,
					onerror: () => showError("Failed to load Google Picker API"),
				});
			}

			function initPicker() {
				try {
					// Create a view that shows only videos
					const docsView = new google.picker.DocsView(
						google.picker.ViewId.DOCS_VIDEOS
					)
						.setIncludeFolders(false)
						.setSelectFolderEnabled(false)
						.setMode(google.picker.DocsViewMode.LIST);

					// Also add a view for all files (user can switch if needed)
					const allFilesView = new google.picker.DocsView()
						.setIncludeFolders(true)
						.setSelectFolderEnabled(false)
						.setMimeTypes("video/*")
						.setMode(google.picker.DocsViewMode.LIST);

					// Build the picker
					const picker = new google.picker.PickerBuilder()
						.setAppId(appId)
						.setDeveloperKey(apiKey)
						.setOAuthToken(accessToken)
						.addView(docsView)
						.addView(allFilesView)
						.enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
						.enableFeature(google.picker.Feature.NAV_HIDDEN)
						.setTitle("Select Videos to Upload")
						.setCallback(pickerCallback)
						.build();

					// Hide loading indicator and show picker
					document.getElementById("loading").style.display = "none";
					picker.setVisible(true);
				} catch (err) {
					showError("Failed to initialize picker: " + err.message);
				}
			}

			function pickerCallback(data) {
				if (data.action === google.picker.Action.PICKED) {
					// User selected files
					const docs = data.docs.map((doc) => ({
						id: doc.id,
						name: doc.name,
						mimeType: doc.mimeType,
						url: doc.url,
						iconUrl: doc.iconUrl,
						parentId: doc.parentId,
					}));

					sendResult({
						type: "PICKER_RESULT",
						action: "picked",
						docs: docs,
					});
				} else if (data.action === google.picker.Action.CANCEL) {
					// User cancelled
					sendResult({
						type: "PICKER_RESULT",
						action: "cancel",
						docs: [],
					});
				}
			}
		</script>
	</body>
</html>
